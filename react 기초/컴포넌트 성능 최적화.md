# 컴포넌트 성능 최적화

## useMemo

사용하지 않는 props가 바뀜에도 비용이 높은 함수가 호출 된다면 자원 낭비가 심해질 것이다. 

```jsx
function useMemo<T>(factory: () => T, deps: DependencyList | undefined): T;
```

deps에 지정한 props가 바뀌지 않았다면 함수를 굳이 다시 호출하지 않고 이전에 반환한 참조값을 재사용 한다.

## useCallback

useMemo는 특정 결과 값을 재사용 한다면, useCallback은 특정 함수를 새로 만들지 않고 재사용하고 싶을 때 사용한다.

상위 컴포넌트에서 하위 컴포넌트로 함수를 props로 넘겨 줄 때, 상위 컴포넌트가 리렌더링 될 때마다 상위 컴포넌트 안에서 생성된 함수를 새로 생성하기 때문에(함수는 객체, 새로 생성된 함수는 다른 참조값을 가짐)

하위 컴포넌트는 props가 달라졌으므로 또 다시 리렌더링 하게 된다.

```jsx
function useCallback<T extends Function>(callback: T, deps: DependencyList): T;
```

사용할 함수를 useCallback으로 감싸준다. 이 때 함수 안에서 사용하는 상태 혹은 props가 있다면 

반드시 deps 배열안에 포함시켜야 한다.

## React.memo

컴포넌트의 props가 바뀌지 않았다면, 리렌더링을 방지한다. 위에서 말한 것처럼 부모컴포넌트가 리렌더링 되면 자식 컴포넌트 또한 리렌더링 된다. 그러나 만약 부모 컴포넌트에서 자식 컴포넌트로 내려주는 props가 바뀌지 않았다면, 해당 자식 컴포넌트는 리렌더링 하지 않아도 될 것이다.

사용법은 그냥 컴포넌트를 감싸주면 된다.

### 언제 사용해야 하는가?

- 컴포넌트가 같은 props로 자주 렌더링 될 때
    - 영화 추천 사이트에서 줄거리, 제목
- 무겁고 비용이 큰 연산이 있는 경우

### 언제 사용하지 말아야 하는가?

- 컴포넌트가 무겁지 않을 때
- 자주 다른 props로 렌더링 되는 경우
    - 영화 추천 사이트에서 관객수, 순위

## useState 함수형 업데이트

useState(state ⇒ state변화)

setusers로 등록하는 콜백함수의 파라미터에서 최신 상태를 참조한다. 

이걸 통해 컴포넌트 최적화 할 수 있다. 이렇게 하면 useCallback을 사용할 때 

두번 째 파라미터로 넣는 배열에 값을 넣어주지 않아도 된다.

## 자식 컴포넌트의 props로 객체를 넘겨줄 때 변형X

```jsx
❌ 쓰면 안돼요 ❌
// 생성자 함수
<Component prop={new Obj("x")} />
// 객체 리터럴
<Component prop={{property: "x"}} />
```

새로 생성된 객체는 컴포넌트가 리렌더링 될때마다 새로운 주소를 가지기 때문에 메모이제이션이 되지 않는다.

그래서 생성자 함수나 객체 리터럴로 객체를 생성해서 하위 컴포넌트에게 넘겨주는 것이 아닌 state을 그대로 넘겨주고, 필요한 데이터 가공은 하위 컴포넌트에서 해주는 것이 좋다.